2D ndarray A matrix of data, passing optional row and column labels
dict of arrays, lists, or tuples Each sequence becomes a column in the DataFrame. All sequences must be the same length.
NumPy structured/record array Treated as the “dict of arrays” case
dict of Series Each value becomes a column. Indexes from each Series are unioned together to form the
result’s row index if no explicit index is passed.
dict of dicts Each inner dict becomes a column. Keys are unioned to form the row index as in the “dict of
Series” case.
list of dicts or Series Each item becomes a row in the DataFrame. Union of dict keys or Series indexes become the
DataFrame’s column labels
List of lists or tuples Treated as the “2D ndarray” case
Another DataFrame The DataFrame’s indexes are used unless different ones are passed
NumPy MaskedArray Like the “2D ndarray” case except masked values become NA/missing in the DataFrame
In [1]: import pandas as pd

In [2]: from pd import Series, DataFrame
---------------------------------------------------------------------------
ImportError                               Traceback (most recent call last)
<ipython-input-2-6605c41b6f5a> in <module>
----> 1 from pd import Series, DataFrame

ImportError: No module named 'pd'

In [3]: import pandas

In [4]: from pandas import Series, DataFrame

In [5]: import pandas as pd

In [6]: obj = Series([4,7,-5,3])

In [7]: obj
Out[7]:
0    4
1    7
2   -5
3    3
dtype: int64

In [8]: obj.values
Out[8]: array([ 4,  7, -5,  3])

In [9]: obj.index
Out[9]: RangeIndex(start=0, stop=4, step=1)

In [10]: obj2 = Series([4,7,-5,3], index=['d','b','a','c'])

In [11]: obj2
Out[11]:
d    4
b    7
a   -5
c    3
dtype: int64

In [12]: obj2.index
Out[12]: Index(['d', 'b', 'a', 'c'], dtype='object')

In [13]: obj2['a']
Out[13]: -5

In [14]: obj2['d']
Out[14]: 4

In [15]: obj2['d'] = 6

In [16]: obj2
Out[16]:
d    6
b    7
a   -5
c    3
dtype: int64

In [17]: obj2[['c','a','d']]
Out[17]:
c    3
a   -5
d    6
dtype: int64

In [18]: obj2
Out[18]:
d    6
b    7
a   -5
c    3
dtype: int64

In [19]: obj2[obj2 > 0]
Out[19]:
d    6
b    7
c    3
dtype: int64

In [20]: obj2 * 2
Out[20]:
d    12
b    14
a   -10
c     6
dtype: int64

In [21]: np.exp(obj2)
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-21-6ae9d3c15d3f> in <module>
----> 1 np.exp(obj2)

NameError: name 'np' is not defined

In [22]: import numpy as np

In [23]: np.exp(obj2)
Out[23]:
d     403.428793
b    1096.633158
a       0.006738
c      20.085537
dtype: float64

In [24]: obj2.dtype
Out[24]: dtype('int64')

In [25]: obj2.shape
Out[25]: (4,)

In [26]: 'b' in obj2
Out[26]: True

In [27]: 'e' in obj2
Out[27]: False

In [28]: sdata = {'Ohio': 35000, 'Texas': 71000, 'Oregon': 16000, 'Utah': 5000}

In [29]: obj3 = Series(sdata)

In [30]: obj3
Out[30]:
Ohio      35000
Oregon    16000
Texas     71000
Utah       5000
dtype: int64

In [31]: obj3.index
Out[31]: Index(['Ohio', 'Oregon', 'Texas', 'Utah'], dtype='object')

In [32]: obj3.values
Out[32]: array([35000, 16000, 71000,  5000])

In [33]: states = ['California', 'Ohio', 'Oregon', 'Texas']

In [34]: obj4 = Series(sdata, index=states)

In [35]: obj4
Out[35]:
California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
dtype: float64

In [36]: isnull
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-36-ae3273fd314f> in <module>
----> 1 isnull

NameError: name 'isnull' is not defined

In [37]: pd.isnull(obj4)
Out[37]:
California     True
Ohio          False
Oregon        False
Texas         False
dtype: bool

In [38]: pd.notnull(obj4)
Out[38]:
California    False
Ohio           True
Oregon         True
Texas          True
dtype: bool

In [39]: obj4.isnull()
Out[39]:
California     True
Ohio          False
Oregon        False
Texas         False
dtype: bool

In [40]: obj3
Out[40]:
Ohio      35000
Oregon    16000
Texas     71000
Utah       5000
dtype: int64

In [41]: obj4
Out[41]:
California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
dtype: float64

In [42]: obj3 + obj4
Out[42]:
California         NaN
Ohio           70000.0
Oregon         32000.0
Texas         142000.0
Utah               NaN
dtype: float64

In [43]: obj3.name

In [44]: obj4
Out[44]:
California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
dtype: float64

In [45]: obj4.name = 'population'

In [46]: obj4.name
Out[46]: 'population'

In [47]: obj4.index
Out[47]: Index(['California', 'Ohio', 'Oregon', 'Texas'], dtype='object')

In [48]: obj4.index.name = 'state'

In [49]: obj4
Out[49]:
state
California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
Name: population, dtype: float64

In [50]: obj
Out[50]:
0    4
1    7
2   -5
3    3
dtype: int64

In [51]: obj.index = ['Bob', 'Steve', 'Jeff', 'Ryan']

In [52]: obj
Out[52]:
Bob      4
Steve    7
Jeff    -5
Ryan     3
dtype: int64

In [53]: obj.index
Out[53]: Index(['Bob', 'Steve', 'Jeff', 'Ryan'], dtype='object')

In [54]: obj.values
Out[54]: array([ 4,  7, -5,  3])

In [55]: data = {'state':['Ohio','Ohio','Ohio','Nevada','Nevada'],'year':[2000,2001,2002,2001,2002],'p
    ...: op':[1.5, 1.7, 3.6, 2.4, 2.9]}

In [56]: data
Out[56]:
{'pop': [1.5, 1.7, 3.6, 2.4, 2.9],
 'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada'],
 'year': [2000, 2001, 2002, 2001, 2002]}

In [57]: frame = DataFrame(data)

In [58]: frame
Out[58]:
   pop   state  year
0  1.5    Ohio  2000
1  1.7    Ohio  2001
2  3.6    Ohio  2002
3  2.4  Nevada  2001
4  2.9  Nevada  2002

In [59]: frame.index
Out[59]: RangeIndex(start=0, stop=5, step=1)

In [60]: frame.values
Out[60]:
array([[1.5, 'Ohio', 2000],
       [1.7, 'Ohio', 2001],
       [3.6, 'Ohio', 2002],
       [2.4, 'Nevada', 2001],
       [2.9, 'Nevada', 2002]], dtype=object)

In [61]: DataFrame(data, columns=['year','state','pop'])
Out[61]:
   year   state  pop
0  2000    Ohio  1.5
1  2001    Ohio  1.7
2  2002    Ohio  3.6
3  2001  Nevada  2.4
4  2002  Nevada  2.9

In [62]: frame
Out[62]:
   pop   state  year
0  1.5    Ohio  2000
1  1.7    Ohio  2001
2  3.6    Ohio  2002
3  2.4  Nevada  2001
4  2.9  Nevada  2002

In [63]: frame2 = DataFrame(data, columns=['year','state','pop','debt'],index=['one','two','three','fo
    ...: ur','five'])

In [64]: frame2
Out[64]:
       year   state  pop debt
one    2000    Ohio  1.5  NaN
two    2001    Ohio  1.7  NaN
three  2002    Ohio  3.6  NaN
four   2001  Nevada  2.4  NaN
five   2002  Nevada  2.9  NaN

In [65]: frame.index
Out[65]: RangeIndex(start=0, stop=5, step=1)

In [66]: frame.values
Out[66]:
array([[1.5, 'Ohio', 2000],
       [1.7, 'Ohio', 2001],
       [3.6, 'Ohio', 2002],
       [2.4, 'Nevada', 2001],
       [2.9, 'Nevada', 2002]], dtype=object)

In [67]: frame2.columns
Out[67]: Index(['year', 'state', 'pop', 'debt'], dtype='object')

In [68]: frame2.rows
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-68-63a392e6ef17> in <module>
----> 1 frame2.rows

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/generic.py in __getattr__(self, name)
   4374             if self._info_axis._can_hold_identifiers_and_holds_name(name):
   4375                 return self[name]
-> 4376             return object.__getattribute__(self, name)
   4377
   4378     def __setattr__(self, name, value):

AttributeError: 'DataFrame' object has no attribute 'rows'

In [69]: frame2.index
Out[69]: Index(['one', 'two', 'three', 'four', 'five'], dtype='object')

In [70]: frame2.columns
Out[70]: Index(['year', 'state', 'pop', 'debt'], dtype='object')

In [71]: frame2['state']
Out[71]:
one        Ohio
two        Ohio
three      Ohio
four     Nevada
five     Nevada
Name: state, dtype: object

In [72]: frame2.year
Out[72]:
one      2000
two      2001
three    2002
four     2001
five     2002
Name: year, dtype: int64

In [73]: frame2.ix
/home/zzp/.conda/envs/torch_04/bin/ipython:1: DeprecationWarning:
.ix is deprecated. Please use
.loc for label based indexing or
.iloc for positional indexing

See the documentation here:
http://pandas.pydata.org/pandas-docs/stable/indexing.html#ix-indexer-is-deprecated
  #!/home/zzp/.conda/envs/torch_04/bin/python
Out[73]: <pandas.core.indexing._IXIndexer at 0x7fc4eb968318>

In [74]: frame2.ix['three']
/home/zzp/.conda/envs/torch_04/bin/ipython:1: DeprecationWarning:
.ix is deprecated. Please use
.loc for label based indexing or
.iloc for positional indexing

See the documentation here:
http://pandas.pydata.org/pandas-docs/stable/indexing.html#ix-indexer-is-deprecated
  #!/home/zzp/.conda/envs/torch_04/bin/python
Out[74]:
year     2002
state    Ohio
pop       3.6
debt      NaN
Name: three, dtype: object

In [75]: frame2
Out[75]:
       year   state  pop debt
one    2000    Ohio  1.5  NaN
two    2001    Ohio  1.7  NaN
three  2002    Ohio  3.6  NaN
four   2001  Nevada  2.4  NaN
five   2002  Nevada  2.9  NaN

In [76]: frame2.ix['two']
/home/zzp/.conda/envs/torch_04/bin/ipython:1: DeprecationWarning:
.ix is deprecated. Please use
.loc for label based indexing or
.iloc for positional indexing

See the documentation here:
http://pandas.pydata.org/pandas-docs/stable/indexing.html#ix-indexer-is-deprecated
  #!/home/zzp/.conda/envs/torch_04/bin/python
Out[76]:
year     2001
state    Ohio
pop       1.7
debt      NaN
Name: two, dtype: object

In [77]: frame2['debt']
Out[77]:
one      NaN
two      NaN
three    NaN
four     NaN
five     NaN
Name: debt, dtype: object

In [78]: frame2['debt'] = 16.5

In [79]: frame2
Out[79]:
       year   state  pop  debt
one    2000    Ohio  1.5  16.5
two    2001    Ohio  1.7  16.5
three  2002    Ohio  3.6  16.5
four   2001  Nevada  2.4  16.5
five   2002  Nevada  2.9  16.5

In [80]: frame2['debt'] = np.arange(5.)

In [81]: frame2
Out[81]:
       year   state  pop  debt
one    2000    Ohio  1.5   0.0
two    2001    Ohio  1.7   1.0
three  2002    Ohio  3.6   2.0
four   2001  Nevada  2.4   3.0
five   2002  Nevada  2.9   4.0

In [82]: fram2.index
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-82-126750100cc5> in <module>
----> 1 fram2.index

NameError: name 'fram2' is not defined

In [83]: frame2.index
Out[83]: Index(['one', 'two', 'three', 'four', 'five'], dtype='object')

In [84]: frame2.values
Out[84]:
array([[2000, 'Ohio', 1.5, 0.0],
       [2001, 'Ohio', 1.7, 1.0],
       [2002, 'Ohio', 3.6, 2.0],
       [2001, 'Nevada', 2.4, 3.0],
       [2002, 'Nevada', 2.9, 4.0]], dtype=object)

In [85]: val = Series([-1.2, -1.5, -1.7], index=['two','four','five'])

In [86]: val
Out[86]:
two    -1.2
four   -1.5
five   -1.7
dtype: float64

In [87]: frame2
Out[87]:
       year   state  pop  debt
one    2000    Ohio  1.5   0.0
two    2001    Ohio  1.7   1.0
three  2002    Ohio  3.6   2.0
four   2001  Nevada  2.4   3.0
five   2002  Nevada  2.9   4.0

In [88]: frame2['debt'] = val

In [89]: frame2
Out[89]:
       year   state  pop  debt
one    2000    Ohio  1.5   NaN
two    2001    Ohio  1.7  -1.2
three  2002    Ohio  3.6   NaN
four   2001  Nevada  2.4  -1.5
five   2002  Nevada  2.9  -1.7

In [90]: frame2
Out[90]:
       year   state  pop  debt
one    2000    Ohio  1.5   NaN
two    2001    Ohio  1.7  -1.2
three  2002    Ohio  3.6   NaN
four   2001  Nevada  2.4  -1.5
five   2002  Nevada  2.9  -1.7

In [91]: frame2['eastern'] = frame2.state == 'Ohio'

In [92]: frame2.state == 'Ohio'
Out[92]:
one       True
two       True
three     True
four     False
five     False
Name: state, dtype: bool

In [93]: frame2
Out[93]:
       year   state  pop  debt  eastern
one    2000    Ohio  1.5   NaN     True
two    2001    Ohio  1.7  -1.2     True
three  2002    Ohio  3.6   NaN     True
four   2001  Nevada  2.4  -1.5    False
five   2002  Nevada  2.9  -1.7    False

In [94]: del frame2['eastern']

In [95]: frame2
Out[95]:
       year   state  pop  debt
one    2000    Ohio  1.5   NaN
two    2001    Ohio  1.7  -1.2
three  2002    Ohio  3.6   NaN
four   2001  Nevada  2.4  -1.5
five   2002  Nevada  2.9  -1.7

In [96]: frame2.columns
Out[96]: Index(['year', 'state', 'pop', 'debt'], dtype='object')

In [97]: pop = {'Nevada': {2001:2.4, 2002: 2.9}, 'Ohio': {2000:1.5, 2001:1.7, 2002:3.6}}

In [98]: pop
Out[98]: {'Nevada': {2001: 2.4, 2002: 2.9}, 'Ohio': {2000: 1.5, 2001: 1.7, 2002: 3.6}}

In [99]: frame3 = DataFrame(pop)

In [100]: frame3
Out[100]:
      Nevada  Ohio
2000     NaN   1.5
2001     2.4   1.7
2002     2.9   3.6

In [101]: frame3.T
Out[101]:
        2000  2001  2002
Nevada   NaN   2.4   2.9
Ohio     1.5   1.7   3.6

In [102]: DataFrame(pop, index=[2001,2002,2003])
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-102-34d43084232e> in <module>
----> 1 DataFrame(pop, index=[2001,2002,2003])

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in __init__(self, data, index, columns, dtype, copy)
    346                                  dtype=dtype, copy=copy)
    347         elif isinstance(data, dict):
--> 348             mgr = self._init_dict(data, index, columns, dtype=dtype)
    349         elif isinstance(data, ma.MaskedArray):
    350             import numpy.ma.mrecords as mrecords

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in _init_dict(self, data, index, columns, dtype)
    457             arrays = [data[k] for k in keys]
    458
--> 459         return _arrays_to_mgr(arrays, data_names, index, columns, dtype=dtype)
    460
    461     def _init_ndarray(self, values, index, columns, dtype=None, copy=False):

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in _arrays_to_mgr(arrays, arr_names, index, columns, dtype)
   7357
   7358     # don't force copy because getting jammed in an ndarray anyway
-> 7359     arrays = _homogenize(arrays, index, dtype)
   7360
   7361     # from BlockManager perspective

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in _homogenize(data, index, dtype)
   7659             if isinstance(v, dict):
   7660                 if oindex is None:
-> 7661                     oindex = index.astype('O')
   7662
   7663                 if isinstance(index, (DatetimeIndex, TimedeltaIndex)):

AttributeError: 'list' object has no attribute 'astype'

In [103]: DataFrame(pop)
Out[103]:
      Nevada  Ohio
2000     NaN   1.5
2001     2.4   1.7
2002     2.9   3.6

In [104]: DataFrame(pop,index=[2001,2002])
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-104-ae1774ad5323> in <module>
----> 1 DataFrame(pop,index=[2001,2002])

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in __init__(self, data, index, columns, dtype, copy)
    346                                  dtype=dtype, copy=copy)
    347         elif isinstance(data, dict):
--> 348             mgr = self._init_dict(data, index, columns, dtype=dtype)
    349         elif isinstance(data, ma.MaskedArray):
    350             import numpy.ma.mrecords as mrecords

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in _init_dict(self, data, index, columns, dtype)
    457             arrays = [data[k] for k in keys]
    458
--> 459         return _arrays_to_mgr(arrays, data_names, index, columns, dtype=dtype)
    460
    461     def _init_ndarray(self, values, index, columns, dtype=None, copy=False):

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in _arrays_to_mgr(arrays, arr_names, index, columns, dtype)
   7357
   7358     # don't force copy because getting jammed in an ndarray anyway
-> 7359     arrays = _homogenize(arrays, index, dtype)
   7360
   7361     # from BlockManager perspective

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in _homogenize(data, index, dtype)
   7659             if isinstance(v, dict):
   7660                 if oindex is None:
-> 7661                     oindex = index.astype('O')
   7662
   7663                 if isinstance(index, (DatetimeIndex, TimedeltaIndex)):

AttributeError: 'list' object has no attribute 'astype'

In [105]: pop
Out[105]: {'Nevada': {2001: 2.4, 2002: 2.9}, 'Ohio': {2000: 1.5, 2001: 1.7, 2002: 3.6}}

In [106]: DataFrame(pop, index=[2001,2002,2003])
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-106-34d43084232e> in <module>
----> 1 DataFrame(pop, index=[2001,2002,2003])

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in __init__(self, data, index, columns, dtype, copy)
    346                                  dtype=dtype, copy=copy)
    347         elif isinstance(data, dict):
--> 348             mgr = self._init_dict(data, index, columns, dtype=dtype)
    349         elif isinstance(data, ma.MaskedArray):
    350             import numpy.ma.mrecords as mrecords

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in _init_dict(self, data, index, columns, dtype)
    457             arrays = [data[k] for k in keys]
    458
--> 459         return _arrays_to_mgr(arrays, data_names, index, columns, dtype=dtype)
    460
    461     def _init_ndarray(self, values, index, columns, dtype=None, copy=False):

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in _arrays_to_mgr(arrays, arr_names, index, columns, dtype)
   7357
   7358     # don't force copy because getting jammed in an ndarray anyway
-> 7359     arrays = _homogenize(arrays, index, dtype)
   7360
   7361     # from BlockManager perspective

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in _homogenize(data, index, dtype)
   7659             if isinstance(v, dict):
   7660                 if oindex is None:
-> 7661                     oindex = index.astype('O')
   7662
   7663                 if isinstance(index, (DatetimeIndex, TimedeltaIndex)):

AttributeError: 'list' object has no attribute 'astype'

In [107]: ?DataFrame

In [108]: DataFrame(pop, index = Series([2001,2002,2003]))
Out[108]:
      Nevada  Ohio
2001     2.4   1.7
2002     2.9   3.6
2003     NaN   NaN

In [109]: DataFrame(pop, columns=['Nevada','Ohio'],index=[2001,2002,2003])
Out[109]:
      Nevada  Ohio
2001     2.4   1.7
2002     2.9   3.6
2003     NaN   NaN

In [110]: frame3
Out[110]:
      Nevada  Ohio
2000     NaN   1.5
2001     2.4   1.7
2002     2.9   3.6

In [111]: frame3['Ohio']
Out[111]:
2000    1.5
2001    1.7
2002    3.6
Name: Ohio, dtype: float64

In [112]: frame3['Ohio'][:-1]
Out[112]:
2000    1.5
2001    1.7
Name: Ohio, dtype: float64

In [113]: frame3['Ohio'][:-1].dtype
Out[113]: dtype('float64')

In [114]: frame3['Ohio'][:-1].index
Out[114]: Int64Index([2000, 2001], dtype='int64')

In [115]: frame3['Ohio'][:-1].class
  File "<ipython-input-115-ca3ba92bbec5>", line 1
    frame3['Ohio'][:-1].class
                            ^
SyntaxError: invalid syntax


In [116]: pdata = {'Ohio': frame3['Ohio'][:-1],'Nevada':frame3['Nevada'][:2]}

In [117]: pdata
Out[117]:
{'Nevada': 2000    NaN
 2001    2.4
 Name: Nevada, dtype: float64, 'Ohio': 2000    1.5
 2001    1.7
 Name: Ohio, dtype: float64}

In [118]: DataFrame(pdata)
Out[118]:
      Nevada  Ohio
2000     NaN   1.5
2001     2.4   1.7

In [119]: frame3
Out[119]:
      Nevada  Ohio
2000     NaN   1.5
2001     2.4   1.7
2002     2.9   3.6

In [120]: frame3.index.name='year'

In [121]: frame3.columns.name='state'

In [122]: frame3
Out[122]:
state  Nevada  Ohio
year
2000      NaN   1.5
2001      2.4   1.7
2002      2.9   3.6

In [123]: frame3
Out[123]:
state  Nevada  Ohio
year
2000      NaN   1.5
2001      2.4   1.7
2002      2.9   3.6

In [124]: frame3.values
Out[124]:
array([[nan, 1.5],
       [2.4, 1.7],
       [2.9, 3.6]])

In [125]: frame2.values
Out[125]:
array([[2000, 'Ohio', 1.5, nan],
       [2001, 'Ohio', 1.7, -1.2],
       [2002, 'Ohio', 3.6, nan],
       [2001, 'Nevada', 2.4, -1.5],
       [2002, 'Nevada', 2.9, -1.7]], dtype=object)
append               Concatenate with additional Index objects, producing a new Index
diff                 Compute set difference as an Index
intersection         Compute set intersection
union                Compute set union
isin                 Compute boolean array indicating whether each value is contained in the passed collection
delete               Compute new Index with element at index i deleted
drop                 Compute new index by deleting passed values
insert               Compute new Index by inserting element at index i
is_monotonic         Returns True if each element is greater than or equal to the previous element
is_unique            Returns True if the Index has no duplicate values
unique               Compute the array of unique values in the Index

In [126]:

In [126]: # index object

In [127]: obj = Series(range(3),index=['a','b','c'])

In [128]: obj
Out[128]:
a    0
b    1
c    2
dtype: int64

In [129]: index = obj.index

In [130]: index
Out[130]: Index(['a', 'b', 'c'], dtype='object')

In [131]: obj.values
Out[131]: array([0, 1, 2])

In [132]: index[1:]
Out[132]: Index(['b', 'c'], dtype='object')

In [133]: index[1]
Out[133]: 'b'

In [134]: index[1] = 'd'
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-134-a452e55ce13b> in <module>
----> 1 index[1] = 'd'

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in __setitem__(self, key, value)
   2063
   2064     def __setitem__(self, key, value):
-> 2065         raise TypeError("Index does not support mutable operations")
   2066
   2067     def __getitem__(self, key):

TypeError: Index does not support mutable operations

In [135]: index[1]
Out[135]: 'b'

In [136]: index[1]='d'
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-136-8be6e68dba2d> in <module>
----> 1 index[1]='d'

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in __setitem__(self, key, value)
   2063
   2064     def __setitem__(self, key, value):
-> 2065         raise TypeError("Index does not support mutable operations")
   2066
   2067     def __getitem__(self, key):

TypeError: Index does not support mutable operations

In [137]: index = pd.Index(np.arange(3))

In [138]: index
Out[138]: Int64Index([0, 1, 2], dtype='int64')

In [139]: frame3
Out[139]:
state  Nevada  Ohio
year
2000      NaN   1.5
2001      2.4   1.7
2002      2.9   3.6

In [140]: 'Ohio ' in frame3.column
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-140-ddef7d51769c> in <module>
----> 1 'Ohio ' in frame3.column

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/generic.py in __getattr__(self, name)
   4374             if self._info_axis._can_hold_identifiers_and_holds_name(name):
   4375                 return self[name]
-> 4376             return object.__getattribute__(self, name)
   4377
   4378     def __setattr__(self, name, value):

AttributeError: 'DataFrame' object has no attribute 'column'

In [141]: 'Ohio ' in frame3.columns
Out[141]: False

In [142]: 'Ohio' in frame3.columns
Out[142]: True

In [143]: frame3
Out[143]:
state  Nevada  Ohio
year
2000      NaN   1.5
2001      2.4   1.7
2002      2.9   3.6

In [144]: '2003' in frame3.index
Out[144]: False

In [145]: '2002' in frame3.index
Out[145]: False

In [146]: 2002 in frame3.index
Out[146]: True

In [147]: # Reindexing

In [148]: obj = Series([4.5, 7.2, -5.3, 3.6], index=['d','b','a','c'])

In [149]: obj
Out[149]:
d    4.5
b    7.2
a   -5.3
c    3.6
dtype: float64

In [150]: obj2 = obj.reindex(['a','b','c','d','e'])

In [151]: obj2
Out[151]:
a   -5.3
b    7.2
c    3.6
d    4.5
e    NaN
dtype: float64

In [152]: obj.reindex(['a','b','c','d','e'],fill_value=0)
Out[152]:
a   -5.3
b    7.2
c    3.6
d    4.5
e    0.0
dtype: float64

In [153]: obj3=Series(['blue','purple','yellow'],index=[0,2,4])

In [154]: obj3
Out[154]:
0      blue
2    purple
4    yellow
dtype: object

In [155]: obj3.reindex(range(6), method='ffill')
Out[155]:
0      blue
1      blue
2    purple
3    purple
4    yellow
5    yellow
dtype: object

In [156]: obj3.reindex(range(6), method='bfill')
Out[156]:
0      blue
1    purple
2    purple
3    yellow
4    yellow
5       NaN
dtype: object

In [157]: np.arange(9).reshape((3,3))
Out[157]:
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])

In [158]: frame = DataFrame(np.arange(9).reshape((3,3)), index=['a','c','d'],columns=['Ohio','Texas','
     ...: California'])

In [159]: frame
Out[159]:
   Ohio  Texas  California
a     0      1           2
c     3      4           5
d     6      7           8

In [160]: frame2 = frame.reindex(['a','b','c','d'])

In [161]: frame2
Out[161]:
   Ohio  Texas  California
a   0.0    1.0         2.0
b   NaN    NaN         NaN
c   3.0    4.0         5.0
d   6.0    7.0         8.0

In [162]: states = ['Texas','Utah','California']

In [163]: frame.reindex(columns=states)
Out[163]:
   Texas  Utah  California
a      1   NaN           2
c      4   NaN           5
d      7   NaN           8

In [164]: frame
Out[164]:
   Ohio  Texas  California
a     0      1           2
c     3      4           5
d     6      7           8

In [165]: frame.reindex(index=['a','b','c','d'],method='ffill',columns=states)
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-165-ce4d39d82f08> in <module>
----> 1 frame.reindex(index=['a','b','c','d'],method='ffill',columns=states)

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/util/_decorators.py in wrapper(*args, **kwargs)
    185         @wraps(func)
    186         def wrapper(*args, **kwargs):
--> 187             return func(*args, **kwargs)
    188
    189         if not PY2:

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in reindex(self, *args, **kwargs)
   3564         kwargs.pop('axis', None)
   3565         kwargs.pop('labels', None)
-> 3566         return super(DataFrame, self).reindex(**kwargs)
   3567
   3568     @Appender(_shared_docs['reindex_axis'] % _shared_doc_kwargs)

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/generic.py in reindex(self, *args, **kwargs)
   3687         # perform the reindex on the axes
   3688         return self._reindex_axes(axes, level, limit, tolerance, method,
-> 3689                                   fill_value, copy).__finalize__(self)
   3690
   3691     def _reindex_axes(self, axes, level, limit, tolerance, method, fill_value,

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in _reindex_axes(self, axes, level, limit, tolerance, method, fill_value, copy)
   3494         if columns is not None:
   3495             frame = frame._reindex_columns(columns, method, copy, level,
-> 3496                                            fill_value, limit, tolerance)
   3497
   3498         index = axes['index']

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in _reindex_columns(self, new_columns, method, copy, level, fill_value, limit, tolerance)
   3516         new_columns, indexer = self.columns.reindex(new_columns, method=method,
   3517                                                     level=level, limit=limit,
-> 3518                                                     tolerance=tolerance)
   3519         return self._reindex_with_indexers({1: [new_columns, indexer]},
   3520                                            copy=copy, fill_value=fill_value,

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in reindex(self, target, method, level, limit, tolerance)
   3620                     indexer = self.get_indexer(target, method=method,
   3621                                                limit=limit,
-> 3622                                                tolerance=tolerance)
   3623                 else:
   3624                     if method is not None or limit is not None:

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in get_indexer(self, target, method, limit, tolerance)
   3246
   3247         if method == 'pad' or method == 'backfill':
-> 3248             indexer = self._get_fill_indexer(target, method, limit, tolerance)
   3249         elif method == 'nearest':
   3250             indexer = self._get_nearest_indexer(target, limit, tolerance)

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in _get_fill_indexer(self, target, method, limit, tolerance)
   3276         else:
   3277             indexer = self._get_fill_indexer_searchsorted(target, method,
-> 3278                                                           limit)
   3279         if tolerance is not None:
   3280             indexer = self._filter_indexer_tolerance(target._ndarray_values,

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in _get_fill_indexer_searchsorted(self, target, method, limit)
   3298         nonexact = (indexer == -1)
   3299         indexer[nonexact] = self._searchsorted_monotonic(target[nonexact],
-> 3300                                                          side)
   3301         if side == 'left':
   3302             # searchsorted returns "indices into a sorted array such that,

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in _searchsorted_monotonic(self, label, side)
   4198             return len(self) - pos
   4199
-> 4200         raise ValueError('index must be monotonic increasing or decreasing')
   4201
   4202     def _get_loc_only_exact_matches(self, key):

ValueError: index must be monotonic increasing or decreasing

In [166]: frame
Out[166]:
   Ohio  Texas  California
a     0      1           2
c     3      4           5
d     6      7           8

In [167]: frame.reindex(method='ffill',columns=states)
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-167-000c335c6c76> in <module>
----> 1 frame.reindex(method='ffill',columns=states)

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/util/_decorators.py in wrapper(*args, **kwargs)
    185         @wraps(func)
    186         def wrapper(*args, **kwargs):
--> 187             return func(*args, **kwargs)
    188
    189         if not PY2:

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in reindex(self, *args, **kwargs)
   3564         kwargs.pop('axis', None)
   3565         kwargs.pop('labels', None)
-> 3566         return super(DataFrame, self).reindex(**kwargs)
   3567
   3568     @Appender(_shared_docs['reindex_axis'] % _shared_doc_kwargs)

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/generic.py in reindex(self, *args, **kwargs)
   3687         # perform the reindex on the axes
   3688         return self._reindex_axes(axes, level, limit, tolerance, method,
-> 3689                                   fill_value, copy).__finalize__(self)
   3690
   3691     def _reindex_axes(self, axes, level, limit, tolerance, method, fill_value,

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in _reindex_axes(self, axes, level, limit, tolerance, method, fill_value, copy)
   3494         if columns is not None:
   3495             frame = frame._reindex_columns(columns, method, copy, level,
-> 3496                                            fill_value, limit, tolerance)
   3497
   3498         index = axes['index']

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in _reindex_columns(self, new_columns, method, copy, level, fill_value, limit, tolerance)
   3516         new_columns, indexer = self.columns.reindex(new_columns, method=method,
   3517                                                     level=level, limit=limit,
-> 3518                                                     tolerance=tolerance)
   3519         return self._reindex_with_indexers({1: [new_columns, indexer]},
   3520                                            copy=copy, fill_value=fill_value,

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in reindex(self, target, method, level, limit, tolerance)
   3620                     indexer = self.get_indexer(target, method=method,
   3621                                                limit=limit,
-> 3622                                                tolerance=tolerance)
   3623                 else:
   3624                     if method is not None or limit is not None:

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in get_indexer(self, target, method, limit, tolerance)
   3246
   3247         if method == 'pad' or method == 'backfill':
-> 3248             indexer = self._get_fill_indexer(target, method, limit, tolerance)
   3249         elif method == 'nearest':
   3250             indexer = self._get_nearest_indexer(target, limit, tolerance)

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in _get_fill_indexer(self, target, method, limit, tolerance)
   3276         else:
   3277             indexer = self._get_fill_indexer_searchsorted(target, method,
-> 3278                                                           limit)
   3279         if tolerance is not None:
   3280             indexer = self._filter_indexer_tolerance(target._ndarray_values,

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in _get_fill_indexer_searchsorted(self, target, method, limit)
   3298         nonexact = (indexer == -1)
   3299         indexer[nonexact] = self._searchsorted_monotonic(target[nonexact],
-> 3300                                                          side)
   3301         if side == 'left':
   3302             # searchsorted returns "indices into a sorted array such that,

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in _searchsorted_monotonic(self, label, side)
   4198             return len(self) - pos
   4199
-> 4200         raise ValueError('index must be monotonic increasing or decreasing')
   4201
   4202     def _get_loc_only_exact_matches(self, key):

ValueError: index must be monotonic increasing or decreasing

In [168]: DataFrame.reindex
Out[168]: <function pandas.core.frame.DataFrame.reindex(self, labels=None, index=None, columns=None, axis=None, method=None, copy=True, level=None, fill_value=nan, limit=None, tolerance=None)>

In [169]: frame.reindex(index=['a','b','c','d'],columns=states)
Out[169]:
   Texas  Utah  California
a    1.0   NaN         2.0
b    NaN   NaN         NaN
c    4.0   NaN         5.0
d    7.0   NaN         8.0

In [170]: frame.reindex(index=['a','b','c','d'],columns=states,method='ffill')
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-170-04ff5b369d50> in <module>
----> 1 frame.reindex(index=['a','b','c','d'],columns=states,method='ffill')

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/util/_decorators.py in wrapper(*args, **kwargs)
    185         @wraps(func)
    186         def wrapper(*args, **kwargs):
--> 187             return func(*args, **kwargs)
    188
    189         if not PY2:

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in reindex(self, *args, **kwargs)
   3564         kwargs.pop('axis', None)
   3565         kwargs.pop('labels', None)
-> 3566         return super(DataFrame, self).reindex(**kwargs)
   3567
   3568     @Appender(_shared_docs['reindex_axis'] % _shared_doc_kwargs)

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/generic.py in reindex(self, *args, **kwargs)
   3687         # perform the reindex on the axes
   3688         return self._reindex_axes(axes, level, limit, tolerance, method,
-> 3689                                   fill_value, copy).__finalize__(self)
   3690
   3691     def _reindex_axes(self, axes, level, limit, tolerance, method, fill_value,

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in _reindex_axes(self, axes, level, limit, tolerance, method, fill_value, copy)
   3494         if columns is not None:
   3495             frame = frame._reindex_columns(columns, method, copy, level,
-> 3496                                            fill_value, limit, tolerance)
   3497
   3498         index = axes['index']

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in _reindex_columns(self, new_columns, method, copy, level, fill_value, limit, tolerance)
   3516         new_columns, indexer = self.columns.reindex(new_columns, method=method,
   3517                                                     level=level, limit=limit,
-> 3518                                                     tolerance=tolerance)
   3519         return self._reindex_with_indexers({1: [new_columns, indexer]},
   3520                                            copy=copy, fill_value=fill_value,

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in reindex(self, target, method, level, limit, tolerance)
   3620                     indexer = self.get_indexer(target, method=method,
   3621                                                limit=limit,
-> 3622                                                tolerance=tolerance)
   3623                 else:
   3624                     if method is not None or limit is not None:

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in get_indexer(self, target, method, limit, tolerance)
   3246
   3247         if method == 'pad' or method == 'backfill':
-> 3248             indexer = self._get_fill_indexer(target, method, limit, tolerance)
   3249         elif method == 'nearest':
   3250             indexer = self._get_nearest_indexer(target, limit, tolerance)

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in _get_fill_indexer(self, target, method, limit, tolerance)
   3276         else:
   3277             indexer = self._get_fill_indexer_searchsorted(target, method,
-> 3278                                                           limit)
   3279         if tolerance is not None:
   3280             indexer = self._filter_indexer_tolerance(target._ndarray_values,

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in _get_fill_indexer_searchsorted(self, target, method, limit)
   3298         nonexact = (indexer == -1)
   3299         indexer[nonexact] = self._searchsorted_monotonic(target[nonexact],
-> 3300                                                          side)
   3301         if side == 'left':
   3302             # searchsorted returns "indices into a sorted array such that,

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in _searchsorted_monotonic(self, label, side)
   4198             return len(self) - pos
   4199
-> 4200         raise ValueError('index must be monotonic increasing or decreasing')
   4201
   4202     def _get_loc_only_exact_matches(self, key):

ValueError: index must be monotonic increasing or decreasing

In [171]: frame.reindex(index=['a','b','c','d'],columns=states).ffill()
Out[171]:
   Texas  Utah  California
a    1.0   NaN         2.0
b    1.0   NaN         2.0
c    4.0   NaN         5.0
d    7.0   NaN         8.0

In [172]: frame.ix[['a','b','c','d'],states]
/home/zzp/.conda/envs/torch_04/bin/ipython:1: DeprecationWarning:
.ix is deprecated. Please use
.loc for label based indexing or
.iloc for positional indexing

See the documentation here:
http://pandas.pydata.org/pandas-docs/stable/indexing.html#ix-indexer-is-deprecated
  #!/home/zzp/.conda/envs/torch_04/bin/python
/home/zzp/.conda/envs/torch_04/bin/ipython:1: FutureWarning:
Passing list-likes to .loc or [] with any missing label will raise
KeyError in the future, you can use .reindex() as an alternative.

See the documentation here:
https://pandas.pydata.org/pandas-docs/stable/indexing.html#deprecate-loc-reindex-listlike
  #!/home/zzp/.conda/envs/torch_04/bin/python
Out[172]:
   Texas  Utah  California
a    1.0   NaN         2.0
b    NaN   NaN         NaN
c    4.0   NaN         5.0
d    7.0   NaN         8.0

In [173]: frame.loc[['a','b','c','d'],states]
/home/zzp/.conda/envs/torch_04/bin/ipython:1: FutureWarning:
Passing list-likes to .loc or [] with any missing label will raise
KeyError in the future, you can use .reindex() as an alternative.

See the documentation here:
https://pandas.pydata.org/pandas-docs/stable/indexing.html#deprecate-loc-reindex-listlike
  #!/home/zzp/.conda/envs/torch_04/bin/python
Out[173]:
   Texas  Utah  California
a    1.0   NaN         2.0
b    NaN   NaN         NaN
c    4.0   NaN         5.0
d    7.0   NaN         8.0

In [174]: ?DataFrame.reindex

In [175]:





###########################################
In [1]: # dropping entries from an axis

In [2]: import pandas

In [3]: from pandas import Series, DataFrame

In [4]: import numpy as np

In [5]: obj = Series(np.arange(5.), index=['a','b','c','d','e'])

In [6]: new_obj = obj.drop('c')

In [7]: new_obj
Out[7]:
a    0.0
b    1.0
d    3.0
e    4.0
dtype: float64

In [8]: obj
Out[8]:
a    0.0
b    1.0
c    2.0
d    3.0
e    4.0
dtype: float64

In [9]: obj.drop(['d','c'])
Out[9]:
a    0.0
b    1.0
e    4.0
dtype: float64

In [10]: # with DataFrame , index values can be deleted from either axis

In [11]: data = DataFrame(np.arange(16.).reshape((4,4)),index=['Ohio','Colorado','Utah','New York'],co
    ...: lumns=['one','two','three','four'])

In [12]: data
Out[12]:
           one   two  three  four
Ohio       0.0   1.0    2.0   3.0
Colorado   4.0   5.0    6.0   7.0
Utah       8.0   9.0   10.0  11.0
New York  12.0  13.0   14.0  15.0

In [13]: data.drop(['Colorado','Ohio'])
Out[13]:
           one   two  three  four
Utah       8.0   9.0   10.0  11.0
New York  12.0  13.0   14.0  15.0

In [14]: data
Out[14]:
           one   two  three  four
Ohio       0.0   1.0    2.0   3.0
Colorado   4.0   5.0    6.0   7.0
Utah       8.0   9.0   10.0  11.0
New York  12.0  13.0   14.0  15.0

In [15]: data.drop('two',axis=1)
Out[15]:
           one  three  four
Ohio       0.0    2.0   3.0
Colorado   4.0    6.0   7.0
Utah       8.0   10.0  11.0
New York  12.0   14.0  15.0

In [16]: data.drop('two')
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
<ipython-input-16-bda5e8137ee9> in <module>
----> 1 data.drop('two')

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in drop(self, labels, axis, in                                                                                                              dex, columns, level, inplace, errors)
   3695                                            index=index, columns=columns,
   3696                                            level=level, inplace=inplace,
-> 3697                                            errors=errors)
   3698
   3699     @rewrite_axis_style_signature('mapper', [('copy', True),

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/generic.py in drop(self, labels, axis,                                                                                                               index, columns, level, inplace, errors)
   3109         for axis, labels in axes.items():
   3110             if labels is not None:
-> 3111                 obj = obj._drop_axis(labels, axis, level=level, errors=errors)
   3112
   3113         if inplace:

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/generic.py in _drop_axis(self, labels,                                                                                                               axis, level, errors)
   3141                 new_axis = axis.drop(labels, level=level, errors=errors)
   3142             else:
-> 3143                 new_axis = axis.drop(labels, errors=errors)
   3144             result = self.reindex(**{axis_name: new_axis})
   3145

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in drop(self, labels, e                                                                                                              rrors)
   4402             if errors != 'ignore':
   4403                 raise KeyError(
-> 4404                     '{} not found in axis'.format(labels[mask]))
   4405             indexer = indexer[~mask]
   4406         return self.delete(indexer)

KeyError: "['two'] not found in axis"

In [17]: data.drop('two',axis=1)
Out[17]:
           one  three  four
Ohio       0.0    2.0   3.0
Colorado   4.0    6.0   7.0
Utah       8.0   10.0  11.0
New York  12.0   14.0  15.0

In [18]: data.drop(['two','four'],axis=1)
Out[18]:
           one  three
Ohio       0.0    2.0
Colorado   4.0    6.0
Utah       8.0   10.0
New York  12.0   14.0

In [19]: # indexing, selection, and filtering

In [20]: # Series indexing (obj[...]) works analogously to Numpy array indexing , except you can use
    ...: the Series's index values instead of only integers.

In [21]: obj = Series(np.arange(4.),index=['a','b','c','d'])

In [22]: obj
Out[22]:
a    0.0
b    1.0
c    2.0
d    3.0
dtype: float64

In [23]: obj['b']
Out[23]: 1.0

In [24]: obj[1]
Out[24]: 1.0

In [25]: obj[1]==obj['b']
Out[25]: True

In [26]: obj[2:4]
Out[26]:
c    2.0
d    3.0
dtype: float64

In [27]: obj[['b','a','d']]
Out[27]:
b    1.0
a    0.0
d    3.0
dtype: float64

In [28]: obj[[1,3]]
Out[28]:
b    1.0
d    3.0
dtype: float64

In [29]: obj[obj<2]
Out[29]:
a    0.0
b    1.0
dtype: float64

In [30]: # slicing with labels behaves differentlt form normal Python slicing in that the endpoint is
    ...: inclusive

In [31]: obj['b':'c']
Out[31]:
b    1.0
c    2.0
dtype: float64

In [32]: obj['b':'c'] = 5

In [33]: obj
Out[33]:
a    0.0
b    5.0
c    5.0
d    3.0
dtype: float64

In [34]: data = DataFrame(np.arange(16).reshape((4,4)),index=['Ohio','Colorado','Utah','New York'], co
    ...: lumns=['one','two','three','four'])

In [35]: data
Out[35]:
          one  two  three  four
Ohio        0    1      2     3
Colorado    4    5      6     7
Utah        8    9     10    11
New York   12   13     14    15

In [36]: data['two']
Out[36]:
Ohio         1
Colorado     5
Utah         9
New York    13
Name: two, dtype: int64

In [37]: data[['three','one']]
Out[37]:
          three  one
Ohio          2    0
Colorado      6    4
Utah         10    8
New York     14   12

In [38]: data[:2]
Out[38]:
          one  two  three  four
Ohio        0    1      2     3
Colorado    4    5      6     7

In [39]: data['Ohio']
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in get_loc(self, key, m                                                                                                              ethod, tolerance)
   3077             try:
-> 3078                 return self._engine.get_loc(key)
   3079             except KeyError:

pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc()

pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc()

pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item()

pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item()

KeyError: 'Ohio'

During handling of the above exception, another exception occurred:

KeyError                                  Traceback (most recent call last)
<ipython-input-39-5bb533c45536> in <module>
----> 1 data['Ohio']

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in __getitem__(self, key)
   2686             return self._getitem_multilevel(key)
   2687         else:
-> 2688             return self._getitem_column(key)
   2689
   2690     def _getitem_column(self, key):

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in _getitem_column(self, key)
   2693         # get column
   2694         if self.columns.is_unique:
-> 2695             return self._get_item_cache(key)
   2696
   2697         # duplicate columns & possible reduce dimensionality

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/generic.py in _get_item_cache(self, ite                                                                                                              m)
   2487         res = cache.get(item)
   2488         if res is None:
-> 2489             values = self._data.get(item)
   2490             res = self._box_item_values(item, values)
   2491             cache[item] = res

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/internals.py in get(self, item, fastpat                                                                                                              h)
   4113
   4114             if not isna(item):
-> 4115                 loc = self.items.get_loc(item)
   4116             else:
   4117                 indexer = np.arange(len(self.items))[isna(self.items)]

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in get_loc(self, key, m                                                                                                              ethod, tolerance)
   3078                 return self._engine.get_loc(key)
   3079             except KeyError:
-> 3080                 return self._engine.get_loc(self._maybe_cast_indexer(key))
   3081
   3082         indexer = self.get_indexer([key], method=method, tolerance=tolerance)

pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc()

pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc()

pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item()

pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item()

KeyError: 'Ohio'

In [40]: data
Out[40]:
          one  two  three  four
Ohio        0    1      2     3
Colorado    4    5      6     7
Utah        8    9     10    11
New York   12   13     14    15

In [41]: data[0]
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in get_loc(self, key, m                                                                                                              ethod, tolerance)
   3077             try:
-> 3078                 return self._engine.get_loc(key)
   3079             except KeyError:

pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc()

pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc()

pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item()

pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item()

KeyError: 0

During handling of the above exception, another exception occurred:

KeyError                                  Traceback (most recent call last)
<ipython-input-41-80a4aab09c73> in <module>
----> 1 data[0]

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in __getitem__(self, key)
   2686             return self._getitem_multilevel(key)
   2687         else:
-> 2688             return self._getitem_column(key)
   2689
   2690     def _getitem_column(self, key):

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in _getitem_column(self, key)
   2693         # get column
   2694         if self.columns.is_unique:
-> 2695             return self._get_item_cache(key)
   2696
   2697         # duplicate columns & possible reduce dimensionality

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/generic.py in _get_item_cache(self, ite                                                                                                              m)
   2487         res = cache.get(item)
   2488         if res is None:
-> 2489             values = self._data.get(item)
   2490             res = self._box_item_values(item, values)
   2491             cache[item] = res

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/internals.py in get(self, item, fastpat                                                                                                              h)
   4113
   4114             if not isna(item):
-> 4115                 loc = self.items.get_loc(item)
   4116             else:
   4117                 indexer = np.arange(len(self.items))[isna(self.items)]

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in get_loc(self, key, m                                                                                                              ethod, tolerance)
   3078                 return self._engine.get_loc(key)
   3079             except KeyError:
-> 3080                 return self._engine.get_loc(self._maybe_cast_indexer(key))
   3081
   3082         indexer = self.get_indexer([key], method=method, tolerance=tolerance)

pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc()

pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc()

pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item()

pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item()

KeyError: 0

In [42]: data[1]
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in get_loc(self, key, m                                                                                                              ethod, tolerance)
   3077             try:
-> 3078                 return self._engine.get_loc(key)
   3079             except KeyError:

pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc()

pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc()

pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item()

pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item()

KeyError: 1

During handling of the above exception, another exception occurred:

KeyError                                  Traceback (most recent call last)
<ipython-input-42-c402bf503b75> in <module>
----> 1 data[1]

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in __getitem__(self, key)
   2686             return self._getitem_multilevel(key)
   2687         else:
-> 2688             return self._getitem_column(key)
   2689
   2690     def _getitem_column(self, key):

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in _getitem_column(self, key)
   2693         # get column
   2694         if self.columns.is_unique:
-> 2695             return self._get_item_cache(key)
   2696
   2697         # duplicate columns & possible reduce dimensionality

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/generic.py in _get_item_cache(self, ite                                                                                                              m)
   2487         res = cache.get(item)
   2488         if res is None:
-> 2489             values = self._data.get(item)
   2490             res = self._box_item_values(item, values)
   2491             cache[item] = res

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/internals.py in get(self, item, fastpat                                                                                                              h)
   4113
   4114             if not isna(item):
-> 4115                 loc = self.items.get_loc(item)
   4116             else:
   4117                 indexer = np.arange(len(self.items))[isna(self.items)]

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in get_loc(self, key, m                                                                                                              ethod, tolerance)
   3078                 return self._engine.get_loc(key)
   3079             except KeyError:
-> 3080                 return self._engine.get_loc(self._maybe_cast_indexer(key))
   3081
   3082         indexer = self.get_indexer([key], method=method, tolerance=tolerance)

pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc()

pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc()

pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item()

pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item()

KeyError: 1

In [43]: data[[1]]
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
<ipython-input-43-ef098c89e942> in <module>
----> 1 data[[1]]

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in __getitem__(self, key)
   2680         if isinstance(key, (Series, np.ndarray, Index, list)):
   2681             # either boolean or fancy integer index
-> 2682             return self._getitem_array(key)
   2683         elif isinstance(key, DataFrame):
   2684             return self._getitem_frame(key)

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in _getitem_array(self, key)
   2724             return self._take(indexer, axis=0)
   2725         else:
-> 2726             indexer = self.loc._convert_to_indexer(key, axis=1)
   2727             return self._take(indexer, axis=1)
   2728

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _convert_to_indexer(self                                                                                                              , obj, axis, is_setter)
   1325                 if mask.any():
   1326                     raise KeyError('{mask} not in index'
-> 1327                                    .format(mask=objarr[mask]))
   1328
   1329                 return com._values_from_object(indexer)

KeyError: '[1] not in index'

In [44]: data[Ohio]
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-44-ecf50dff7f5e> in <module>
----> 1 data[Ohio]

NameError: name 'Ohio' is not defined

In [45]: data[ohio]
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-45-1bdc2189a26f> in <module>
----> 1 data[ohio]

NameError: name 'ohio' is not defined

In [46]: data['ohio']
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in get_loc(self, key, m                                                                                                              ethod, tolerance)
   3077             try:
-> 3078                 return self._engine.get_loc(key)
   3079             except KeyError:

pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc()

pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc()

pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item()

pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item()

KeyError: 'ohio'

During handling of the above exception, another exception occurred:

KeyError                                  Traceback (most recent call last)
<ipython-input-46-3728935abc9d> in <module>
----> 1 data['ohio']

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in __getitem__(self, key)
   2686             return self._getitem_multilevel(key)
   2687         else:
-> 2688             return self._getitem_column(key)
   2689
   2690     def _getitem_column(self, key):

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in _getitem_column(self, key)
   2693         # get column
   2694         if self.columns.is_unique:
-> 2695             return self._get_item_cache(key)
   2696
   2697         # duplicate columns & possible reduce dimensionality

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/generic.py in _get_item_cache(self, ite                                                                                                              m)
   2487         res = cache.get(item)
   2488         if res is None:
-> 2489             values = self._data.get(item)
   2490             res = self._box_item_values(item, values)
   2491             cache[item] = res

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/internals.py in get(self, item, fastpat                                                                                                              h)
   4113
   4114             if not isna(item):
-> 4115                 loc = self.items.get_loc(item)
   4116             else:
   4117                 indexer = np.arange(len(self.items))[isna(self.items)]

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in get_loc(self, key, m                                                                                                              ethod, tolerance)
   3078                 return self._engine.get_loc(key)
   3079             except KeyError:
-> 3080                 return self._engine.get_loc(self._maybe_cast_indexer(key))
   3081
   3082         indexer = self.get_indexer([key], method=method, tolerance=tolerance)

pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc()

pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc()

pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item()

pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item()

KeyError: 'ohio'

In [47]: data
Out[47]:
          one  two  three  four
Ohio        0    1      2     3
Colorado    4    5      6     7
Utah        8    9     10    11
New York   12   13     14    15

In [48]: data[['three']]
Out[48]:
          three
Ohio          2
Colorado      6
Utah         10
New York     14

In [49]: data[:1]
Out[49]:
      one  two  three  four
Ohio    0    1      2     3

In [50]: data[:]
Out[50]:
          one  two  three  four
Ohio        0    1      2     3
Colorado    4    5      6     7
Utah        8    9     10    11
New York   12   13     14    15

In [51]: data[:2]
Out[51]:
          one  two  three  four
Ohio        0    1      2     3
Colorado    4    5      6     7

In [52]: data[0:2]
Out[52]:
          one  two  three  four
Ohio        0    1      2     3
Colorado    4    5      6     7

In [53]: data[0:1]
Out[53]:
      one  two  three  four
Ohio    0    1      2     3

In [54]: data[1:1]
Out[54]:
Empty DataFrame
Columns: [one, two, three, four]
Index: []

In [55]: data[data['three']>5]
Out[55]:
          one  two  three  four
Colorado    4    5      6     7
Utah        8    9     10    11
New York   12   13     14    15

In [56]: data
Out[56]:
          one  two  three  four
Ohio        0    1      2     3
Colorado    4    5      6     7
Utah        8    9     10    11
New York   12   13     14    15

In [57]: data < 5
Out[57]:
            one    two  three   four
Ohio       True   True   True   True
Colorado   True  False  False  False
Utah      False  False  False  False
New York  False  False  False  False

In [58]: data[data<5]=0

In [59]: data
Out[59]:
          one  two  three  four
Ohio        0    0      0     0
Colorado    0    5      6     7
Utah        8    9     10    11
New York   12   13     14    15

In [60]: data
Out[60]:
          one  two  three  four
Ohio        0    0      0     0
Colorado    0    5      6     7
Utah        8    9     10    11
New York   12   13     14    15

In [61]: data.ix['Colorado',['two','three']]
/home/zzp/.conda/envs/torch_04/bin/ipython:1: DeprecationWarning:
.ix is deprecated. Please use
.loc for label based indexing or
.iloc for positional indexing

See the documentation here:
http://pandas.pydata.org/pandas-docs/stable/indexing.html#ix-indexer-is-deprecated
  #!/home/zzp/.conda/envs/torch_04/bin/python
Out[61]:
two      5
three    6
Name: Colorado, dtype: int64

In [62]: data.loc['Colorado',['two','three']]
Out[62]:
two      5
three    6
Name: Colorado, dtype: int64

In [63]: data.loc[['Colorado','Utah'],[3,0,1]]
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _multi_take(self, tup)
    940                 self._validate_read_indexer(keyarr, indexer,
--> 941                                             o._get_axis_number(axis))
    942                 d[axis] = (keyarr, indexer)

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _validate_read_indexer(s                                                                                                              elf, key, indexer, axis)
   1205                     u"None of [{key}] are in the [{axis}]".format(
-> 1206                         key=key, axis=self.obj._get_axis_name(axis)))
   1207

KeyError: "None of [Int64Index([3, 0, 1], dtype='int64')] are in the [columns]"

During handling of the above exception, another exception occurred:

KeyError                                  Traceback (most recent call last)
<ipython-input-63-b72706fa04d7> in <module>
----> 1 data.loc[['Colorado','Utah'],[3,0,1]]

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in __getitem__(self, key)
   1470             except (KeyError, IndexError):
   1471                 pass
-> 1472             return self._getitem_tuple(key)
   1473         else:
   1474             # we by definition only have the 0th axis

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _getitem_tuple(self, tup                                                                                                              )
    877         # ugly hack for GH #836
    878         if self._multi_take_opportunity(tup):
--> 879             return self._multi_take(tup)
    880
    881         # no shortcut needed

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _multi_take(self, tup)
    943             return o._reindex_with_indexers(d, copy=True, allow_dups=True)
    944         except (KeyError, IndexingError) as detail:
--> 945             raise self._exception(detail)
    946
    947     def _convert_for_reindex(self, key, axis=None):

KeyError: KeyError("None of [Int64Index([3, 0, 1], dtype='int64')] are in the [columns]",)

In [64]: data.iloc[['Colorado','Utah'],[3,0,1]]
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-64-00db07f466da> in <module>
----> 1 data.iloc[['Colorado','Utah'],[3,0,1]]

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in __getitem__(self, key)
   1470             except (KeyError, IndexError):
   1471                 pass
-> 1472             return self._getitem_tuple(key)
   1473         else:
   1474             # we by definition only have the 0th axis

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _getitem_tuple(self, tup                                                                                                              )
   2011     def _getitem_tuple(self, tup):
   2012
-> 2013         self._has_valid_tuple(tup)
   2014         try:
   2015             return self._getitem_lowerdim(tup)

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _has_valid_tuple(self, k                                                                                                              ey)
    220                 raise IndexingError('Too many indexers')
    221             try:
--> 222                 self._validate_key(k, i)
    223             except ValueError:
    224                 raise ValueError("Location based indexing can only have "

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _validate_key(self, key,                                                                                                               axis)
   1965             l = len(self.obj._get_axis(axis))
   1966
-> 1967             if len(arr) and (arr.max() >= l or arr.min() < -l):
   1968                 raise IndexError("positional indexers are out-of-bounds")
   1969         else:

~/.conda/envs/torch_04/lib/python3.5/site-packages/numpy/core/_methods.py in _amax(a, axis, out, keepd                                                                                                              ims, initial)
     26 def _amax(a, axis=None, out=None, keepdims=False,
     27           initial=_NoValue):
---> 28     return umr_maximum(a, axis, None, out, keepdims, initial)
     29
     30 def _amin(a, axis=None, out=None, keepdims=False,

TypeError: cannot perform reduce with flexible type

In [65]: data.ix[['Colorado','Utah'],[3,0,1]]
/home/zzp/.conda/envs/torch_04/bin/ipython:1: DeprecationWarning:
.ix is deprecated. Please use
.loc for label based indexing or
.iloc for positional indexing

See the documentation here:
http://pandas.pydata.org/pandas-docs/stable/indexing.html#ix-indexer-is-deprecated
  #!/home/zzp/.conda/envs/torch_04/bin/python
Out[65]:
          four  one  two
Colorado     7    0    5
Utah        11    8    9

In [66]: data.loc[['Colorado','Utah'],[3,0,1]]
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _multi_take(self, tup)
    940                 self._validate_read_indexer(keyarr, indexer,
--> 941                                             o._get_axis_number(axis))
    942                 d[axis] = (keyarr, indexer)

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _validate_read_indexer(s                                                                                                              elf, key, indexer, axis)
   1205                     u"None of [{key}] are in the [{axis}]".format(
-> 1206                         key=key, axis=self.obj._get_axis_name(axis)))
   1207

KeyError: "None of [Int64Index([3, 0, 1], dtype='int64')] are in the [columns]"

During handling of the above exception, another exception occurred:

KeyError                                  Traceback (most recent call last)
<ipython-input-66-b72706fa04d7> in <module>
----> 1 data.loc[['Colorado','Utah'],[3,0,1]]

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in __getitem__(self, key)
   1470             except (KeyError, IndexError):
   1471                 pass
-> 1472             return self._getitem_tuple(key)
   1473         else:
   1474             # we by definition only have the 0th axis

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _getitem_tuple(self, tup                                                                                                              )
    877         # ugly hack for GH #836
    878         if self._multi_take_opportunity(tup):
--> 879             return self._multi_take(tup)
    880
    881         # no shortcut needed

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _multi_take(self, tup)
    943             return o._reindex_with_indexers(d, copy=True, allow_dups=True)
    944         except (KeyError, IndexingError) as detail:
--> 945             raise self._exception(detail)
    946
    947     def _convert_for_reindex(self, key, axis=None):

KeyError: KeyError("None of [Int64Index([3, 0, 1], dtype='int64')] are in the [columns]",)

In [67]: data.loc[['Colorado','Utah'],Series([3,0,1])]
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _multi_take(self, tup)
    940                 self._validate_read_indexer(keyarr, indexer,
--> 941                                             o._get_axis_number(axis))
    942                 d[axis] = (keyarr, indexer)

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _validate_read_indexer(s                                                                                                              elf, key, indexer, axis)
   1205                     u"None of [{key}] are in the [{axis}]".format(
-> 1206                         key=key, axis=self.obj._get_axis_name(axis)))
   1207

KeyError: "None of [Int64Index([3, 0, 1], dtype='int64')] are in the [columns]"

During handling of the above exception, another exception occurred:

KeyError                                  Traceback (most recent call last)
<ipython-input-67-5f3c7cdfb8e3> in <module>
----> 1 data.loc[['Colorado','Utah'],Series([3,0,1])]

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in __getitem__(self, key)
   1470             except (KeyError, IndexError):
   1471                 pass
-> 1472             return self._getitem_tuple(key)
   1473         else:
   1474             # we by definition only have the 0th axis

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _getitem_tuple(self, tup                                                                                                              )
    877         # ugly hack for GH #836
    878         if self._multi_take_opportunity(tup):
--> 879             return self._multi_take(tup)
    880
    881         # no shortcut needed

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _multi_take(self, tup)
    943             return o._reindex_with_indexers(d, copy=True, allow_dups=True)
    944         except (KeyError, IndexingError) as detail:
--> 945             raise self._exception(detail)
    946
    947     def _convert_for_reindex(self, key, axis=None):

KeyError: KeyError("None of [Int64Index([3, 0, 1], dtype='int64')] are in the [columns]",)

In [68]: data.loc[['Colorado','Utah'],[3,0,1]]
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _multi_take(self, tup)
    940                 self._validate_read_indexer(keyarr, indexer,
--> 941                                             o._get_axis_number(axis))
    942                 d[axis] = (keyarr, indexer)

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _validate_read_indexer(s                                                                                                              elf, key, indexer, axis)
   1205                     u"None of [{key}] are in the [{axis}]".format(
-> 1206                         key=key, axis=self.obj._get_axis_name(axis)))
   1207

KeyError: "None of [Int64Index([3, 0, 1], dtype='int64')] are in the [columns]"

During handling of the above exception, another exception occurred:

KeyError                                  Traceback (most recent call last)
<ipython-input-68-b72706fa04d7> in <module>
----> 1 data.loc[['Colorado','Utah'],[3,0,1]]

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in __getitem__(self, key)
   1470             except (KeyError, IndexError):
   1471                 pass
-> 1472             return self._getitem_tuple(key)
   1473         else:
   1474             # we by definition only have the 0th axis

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _getitem_tuple(self, tup                                                                                                              )
    877         # ugly hack for GH #836
    878         if self._multi_take_opportunity(tup):
--> 879             return self._multi_take(tup)
    880
    881         # no shortcut needed

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _multi_take(self, tup)
    943             return o._reindex_with_indexers(d, copy=True, allow_dups=True)
    944         except (KeyError, IndexingError) as detail:
--> 945             raise self._exception(detail)
    946
    947     def _convert_for_reindex(self, key, axis=None):

KeyError: KeyError("None of [Int64Index([3, 0, 1], dtype='int64')] are in the [columns]",)

In [69]: data.iloc[['Colorado','Utah'],[3,0,1]]
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-69-00db07f466da> in <module>
----> 1 data.iloc[['Colorado','Utah'],[3,0,1]]

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in __getitem__(self, key)
   1470             except (KeyError, IndexError):
   1471                 pass
-> 1472             return self._getitem_tuple(key)
   1473         else:
   1474             # we by definition only have the 0th axis

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _getitem_tuple(self, tup                                                                                                              )
   2011     def _getitem_tuple(self, tup):
   2012
-> 2013         self._has_valid_tuple(tup)
   2014         try:
   2015             return self._getitem_lowerdim(tup)

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _has_valid_tuple(self, k                                                                                                              ey)
    220                 raise IndexingError('Too many indexers')
    221             try:
--> 222                 self._validate_key(k, i)
    223             except ValueError:
    224                 raise ValueError("Location based indexing can only have "

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _validate_key(self, key,                                                                                                               axis)
   1965             l = len(self.obj._get_axis(axis))
   1966
-> 1967             if len(arr) and (arr.max() >= l or arr.min() < -l):
   1968                 raise IndexError("positional indexers are out-of-bounds")
   1969         else:

~/.conda/envs/torch_04/lib/python3.5/site-packages/numpy/core/_methods.py in _amax(a, axis, out, keepd                                                                                                              ims, initial)
     26 def _amax(a, axis=None, out=None, keepdims=False,
     27           initial=_NoValue):
---> 28     return umr_maximum(a, axis, None, out, keepdims, initial)
     29
     30 def _amin(a, axis=None, out=None, keepdims=False,

TypeError: cannot perform reduce with flexible type

In [70]: data.iloc[['Colorado','Utah'],Series([3,0,1])]
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-70-6c4e0499eeca> in <module>
----> 1 data.iloc[['Colorado','Utah'],Series([3,0,1])]

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in __getitem__(self, key)
   1470             except (KeyError, IndexError):
   1471                 pass
-> 1472             return self._getitem_tuple(key)
   1473         else:
   1474             # we by definition only have the 0th axis

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _getitem_tuple(self, tup                                                                                                              )
   2011     def _getitem_tuple(self, tup):
   2012
-> 2013         self._has_valid_tuple(tup)
   2014         try:
   2015             return self._getitem_lowerdim(tup)

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _has_valid_tuple(self, k                                                                                                              ey)
    220                 raise IndexingError('Too many indexers')
    221             try:
--> 222                 self._validate_key(k, i)
    223             except ValueError:
    224                 raise ValueError("Location based indexing can only have "

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _validate_key(self, key,                                                                                                               axis)
   1965             l = len(self.obj._get_axis(axis))
   1966
-> 1967             if len(arr) and (arr.max() >= l or arr.min() < -l):
   1968                 raise IndexError("positional indexers are out-of-bounds")
   1969         else:

~/.conda/envs/torch_04/lib/python3.5/site-packages/numpy/core/_methods.py in _amax(a, axis, out, keepd                                                                                                              ims, initial)
     26 def _amax(a, axis=None, out=None, keepdims=False,
     27           initial=_NoValue):
---> 28     return umr_maximum(a, axis, None, out, keepdims, initial)
     29
     30 def _amin(a, axis=None, out=None, keepdims=False,

TypeError: cannot perform reduce with flexible type

In [71]: data.ix[['Colorado','Utah'],[3,0,1]]
/home/zzp/.conda/envs/torch_04/bin/ipython:1: DeprecationWarning:
.ix is deprecated. Please use
.loc for label based indexing or
.iloc for positional indexing

See the documentation here:
http://pandas.pydata.org/pandas-docs/stable/indexing.html#ix-indexer-is-deprecated
  #!/home/zzp/.conda/envs/torch_04/bin/python
Out[71]:
          four  one  two
Colorado     7    0    5
Utah        11    8    9

In [72]: data.ix[2]
/home/zzp/.conda/envs/torch_04/bin/ipython:1: DeprecationWarning:
.ix is deprecated. Please use
.loc for label based indexing or
.iloc for positional indexing

See the documentation here:
http://pandas.pydata.org/pandas-docs/stable/indexing.html#ix-indexer-is-deprecated
  #!/home/zzp/.conda/envs/torch_04/bin/python
Out[72]:
one       8
two       9
three    10
four     11
Name: Utah, dtype: int64

In [73]: data.loc[2]
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-73-870ecc20c9fe> in <module>
----> 1 data.loc[2]

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in __getitem__(self, key)
   1476
   1477             maybe_callable = com._apply_if_callable(key, self.obj)
-> 1478             return self._getitem_axis(maybe_callable, axis=axis)
   1479
   1480     def _is_scalar_access(self, key):

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _getitem_axis(self, key,                                                                                                               axis)
   1909
   1910         # fall thru to straight lookup
-> 1911         self._validate_key(key, axis)
   1912         return self._get_label(key, axis=axis)
   1913

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _validate_key(self, key,                                                                                                               axis)
   1786
   1787             try:
-> 1788                 key = self._convert_scalar_indexer(key, axis)
   1789                 if not ax.contains(key):
   1790                     error()

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _convert_scalar_indexer(                                                                                                              self, key, axis)
    259         ax = self.obj._get_axis(min(axis, self.ndim - 1))
    260         # a scalar
--> 261         return ax._convert_scalar_indexer(key, kind=self.name)
    262
    263     def _convert_slice_indexer(self, key, axis):

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in _convert_scalar_inde                                                                                                              xer(self, key, kind)
   1677             elif kind in ['loc'] and is_integer(key):
   1678                 if not self.holds_integer():
-> 1679                     return self._invalid_indexer('label', key)
   1680
   1681         return key

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in _invalid_indexer(sel                                                                                                              f, form, key)
   1861                         "indexers [{key}] of {kind}".format(
   1862                             form=form, klass=type(self), key=key,
-> 1863                             kind=type(key)))
   1864
   1865     def get_duplicates(self):

TypeError: cannot do label indexing on <class 'pandas.core.indexes.base.Index'> with these indexers [2                                                                                                              ] of <class 'int'>

In [74]: data.iloc[2]
Out[74]:
one       8
two       9
three    10
four     11
Name: Utah, dtype: int64

In [75]: data.iloc[2,[3]]
Out[75]:
four    11
Name: Utah, dtype: int64

In [76]: data.iloc[2,[3,0,1]]
Out[76]:
four    11
one      8
two      9
Name: Utah, dtype: int64

In [77]: data.loc[:'Utah','two']
Out[77]:
Ohio        0
Colorado    5
Utah        9
Name: two, dtype: int64

In [78]: data
Out[78]:
          one  two  three  four
Ohio        0    0      0     0
Colorado    0    5      6     7
Utah        8    9     10    11
New York   12   13     14    15

In [79]: data.iloc[:2]
Out[79]:
          one  two  three  four
Ohio        0    0      0     0
Colorado    0    5      6     7

In [80]: data.loc[:'Utah','two']
Out[80]:
Ohio        0
Colorado    5
Utah        9
Name: two, dtype: int64

In [81]: data.ix[data.three > 5,:3]
/home/zzp/.conda/envs/torch_04/bin/ipython:1: DeprecationWarning:
.ix is deprecated. Please use
.loc for label based indexing or
.iloc for positional indexing

See the documentation here:
http://pandas.pydata.org/pandas-docs/stable/indexing.html#ix-indexer-is-deprecated
  #!/home/zzp/.conda/envs/torch_04/bin/python
Out[81]:
          one  two  three
Colorado    0    5      6
Utah        8    9     10
New York   12   13     14

In [82]: data.iloc[data.three > 5,:3]
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _has_valid_tuple(self, k                                                                                                              ey)
    221             try:
--> 222                 self._validate_key(k, i)
    223             except ValueError:

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _validate_key(self, key,                                                                                                               axis)
   1949                                               "is not available")
-> 1950                 raise ValueError("iLocation based boolean indexing cannot use "
   1951                                  "an indexable as a mask")

ValueError: iLocation based boolean indexing cannot use an indexable as a mask

During handling of the above exception, another exception occurred:

ValueError                                Traceback (most recent call last)
<ipython-input-82-39dc1ea453ee> in <module>
----> 1 data.iloc[data.three > 5,:3]

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in __getitem__(self, key)
   1470             except (KeyError, IndexError):
   1471                 pass
-> 1472             return self._getitem_tuple(key)
   1473         else:
   1474             # we by definition only have the 0th axis

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _getitem_tuple(self, tup                                                                                                              )
   2011     def _getitem_tuple(self, tup):
   2012
-> 2013         self._has_valid_tuple(tup)
   2014         try:
   2015             return self._getitem_lowerdim(tup)

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _has_valid_tuple(self, k                                                                                                              ey)
    224                 raise ValueError("Location based indexing can only have "
    225                                  "[{types}] types"
--> 226                                  .format(types=self._valid_types))
    227
    228     def _is_nested_tuple_indexer(self, tup):

ValueError: Location based indexing can only have [integer, integer slice (START point is INCLUDED, EN                                                                                                              D point is EXCLUDED), listlike of integers, boolean array] types

In [83]: data.three > 5
Out[83]:
Ohio        False
Colorado     True
Utah         True
New York     True
Name: three, dtype: bool

In [84]: data.ix[data.three > 5,:3]
/home/zzp/.conda/envs/torch_04/bin/ipython:1: DeprecationWarning:
.ix is deprecated. Please use
.loc for label based indexing or
.iloc for positional indexing

See the documentation here:
http://pandas.pydata.org/pandas-docs/stable/indexing.html#ix-indexer-is-deprecated
  #!/home/zzp/.conda/envs/torch_04/bin/python
Out[84]:
          one  two  three
Colorado    0    5      6
Utah        8    9     10
New York   12   13     14

In [85]: data.iloc[data.three > 5,:3]
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _has_valid_tuple(self, k                                                                                                              ey)
    221             try:
--> 222                 self._validate_key(k, i)
    223             except ValueError:

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _validate_key(self, key,                                                                                                               axis)
   1949                                               "is not available")
-> 1950                 raise ValueError("iLocation based boolean indexing cannot use "
   1951                                  "an indexable as a mask")

ValueError: iLocation based boolean indexing cannot use an indexable as a mask

During handling of the above exception, another exception occurred:

ValueError                                Traceback (most recent call last)
<ipython-input-85-39dc1ea453ee> in <module>
----> 1 data.iloc[data.three > 5,:3]

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in __getitem__(self, key)
   1470             except (KeyError, IndexError):
   1471                 pass
-> 1472             return self._getitem_tuple(key)
   1473         else:
   1474             # we by definition only have the 0th axis

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _getitem_tuple(self, tup                                                                                                              )
   2011     def _getitem_tuple(self, tup):
   2012
-> 2013         self._has_valid_tuple(tup)
   2014         try:
   2015             return self._getitem_lowerdim(tup)

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _has_valid_tuple(self, k                                                                                                              ey)
    224                 raise ValueError("Location based indexing can only have "
    225                                  "[{types}] types"
--> 226                                  .format(types=self._valid_types))
    227
    228     def _is_nested_tuple_indexer(self, tup):

ValueError: Location based indexing can only have [integer, integer slice (START point is INCLUDED, EN                                                                                                              D point is EXCLUDED), listlike of integers, boolean array] types

In [86]: data.ix[data.three > 5,:3]
/home/zzp/.conda/envs/torch_04/bin/ipython:1: DeprecationWarning:
.ix is deprecated. Please use
.loc for label based indexing or
.iloc for positional indexing

See the documentation here:
http://pandas.pydata.org/pandas-docs/stable/indexing.html#ix-indexer-is-deprecated
  #!/home/zzp/.conda/envs/torch_04/bin/python
Out[86]:
          one  two  three
Colorado    0    5      6
Utah        8    9     10
New York   12   13     14

In [87]: data.ix[data.three > 5]
/home/zzp/.conda/envs/torch_04/bin/ipython:1: DeprecationWarning:
.ix is deprecated. Please use
.loc for label based indexing or
.iloc for positional indexing

See the documentation here:
http://pandas.pydata.org/pandas-docs/stable/indexing.html#ix-indexer-is-deprecated
  #!/home/zzp/.conda/envs/torch_04/bin/python
Out[87]:
          one  two  three  four
Colorado    0    5      6     7
Utah        8    9     10    11
New York   12   13     14    15

In [88]: data.iloc[data.three > 5]
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-88-7b058b0ab096> in <module>
----> 1 data.iloc[data.three > 5]

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in __getitem__(self, key)
   1476
   1477             maybe_callable = com._apply_if_callable(key, self.obj)
-> 1478             return self._getitem_axis(maybe_callable, axis=axis)
   1479
   1480     def _is_scalar_access(self, key):

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _getitem_axis(self, key,                                                                                                               axis)
   2084
   2085         if com.is_bool_indexer(key):
-> 2086             self._validate_key(key, axis)
   2087             return self._getbool_axis(key, axis=axis)
   2088

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _validate_key(self, key,                                                                                                               axis)
   1948                                               "indexing on an integer type "
   1949                                               "is not available")
-> 1950                 raise ValueError("iLocation based boolean indexing cannot use "
   1951                                  "an indexable as a mask")
   1952             return

ValueError: iLocation based boolean indexing cannot use an indexable as a mask

In [89]: data.loc[data.three > 5]
Out[89]:
          one  two  three  four
Colorado    0    5      6     7
Utah        8    9     10    11
New York   12   13     14    15

In [90]: data.loc[data.three > 5]
Out[90]:
          one  two  three  four
Colorado    0    5      6     7
Utah        8    9     10    11
New York   12   13     14    15

In [91]: data.loc[data.three > 5]0[]
  File "<ipython-input-91-c1dc4330f7aa>", line 1
    data.loc[data.three > 5]0[]
                            ^
SyntaxError: invalid syntax


In [92]: data.loc[data.three > 5][0]
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in get_loc(self, key, m                                                                                                              ethod, tolerance)
   3077             try:
-> 3078                 return self._engine.get_loc(key)
   3079             except KeyError:

pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc()

pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc()

pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item()

pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item()

KeyError: 0

During handling of the above exception, another exception occurred:

KeyError                                  Traceback (most recent call last)
<ipython-input-92-8a3babb2282e> in <module>
----> 1 data.loc[data.three > 5][0]

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in __getitem__(self, key)
   2686             return self._getitem_multilevel(key)
   2687         else:
-> 2688             return self._getitem_column(key)
   2689
   2690     def _getitem_column(self, key):

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in _getitem_column(self, key)
   2693         # get column
   2694         if self.columns.is_unique:
-> 2695             return self._get_item_cache(key)
   2696
   2697         # duplicate columns & possible reduce dimensionality

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/generic.py in _get_item_cache(self, ite                                                                                                              m)
   2487         res = cache.get(item)
   2488         if res is None:
-> 2489             values = self._data.get(item)
   2490             res = self._box_item_values(item, values)
   2491             cache[item] = res

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/internals.py in get(self, item, fastpat                                                                                                              h)
   4113
   4114             if not isna(item):
-> 4115                 loc = self.items.get_loc(item)
   4116             else:
   4117                 indexer = np.arange(len(self.items))[isna(self.items)]

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in get_loc(self, key, m                                                                                                              ethod, tolerance)
   3078                 return self._engine.get_loc(key)
   3079             except KeyError:
-> 3080                 return self._engine.get_loc(self._maybe_cast_indexer(key))
   3081
   3082         indexer = self.get_indexer([key], method=method, tolerance=tolerance)

pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc()

pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc()

pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item()

pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item()

KeyError: 0

In [93]: data.loc[data.three > 5]
Out[93]:
          one  two  three  four
Colorado    0    5      6     7
Utah        8    9     10    11
New York   12   13     14    15

In [94]: data.loc[data.three > 5].class
  File "<ipython-input-94-a620a54894cc>", line 1
    data.loc[data.three > 5].class
                                 ^
SyntaxError: invalid syntax


In [95]: data.loc[data.three > 5].dtype
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-95-dcc5a67c36be> in <module>
----> 1 data.loc[data.three > 5].dtype

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/generic.py in __getattr__(self, name)
   4374             if self._info_axis._can_hold_identifiers_and_holds_name(name):
   4375                 return self[name]
-> 4376             return object.__getattribute__(self, name)
   4377
   4378     def __setattr__(self, name, value):

AttributeError: 'DataFrame' object has no attribute 'dtype'

In [96]: data.loc[data.three > 5].shape
Out[96]: (3, 4)

In [97]: data.loc[data.three > 5][:]
Out[97]:
          one  two  three  four
Colorado    0    5      6     7
Utah        8    9     10    11
New York   12   13     14    15

In [98]: data.loc[data.three > 5][:3]
Out[98]:
          one  two  three  four
Colorado    0    5      6     7
Utah        8    9     10    11
New York   12   13     14    15

In [99]: data.loc[data.three > 5][:2]
Out[99]:
          one  two  three  four
Colorado    0    5      6     7
Utah        8    9     10    11

In [100]: data.loc[data.three > 5,0]
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-100-f3cbe96ce387> in <module>
----> 1 data.loc[data.three > 5,0]

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in __getitem__(self, key)
   1470             except (KeyError, IndexError):
   1471                 pass
-> 1472             return self._getitem_tuple(key)
   1473         else:
   1474             # we by definition only have the 0th axis

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _getitem_tuple(self, tup                                                                                                              )
    868     def _getitem_tuple(self, tup):
    869         try:
--> 870             return self._getitem_lowerdim(tup)
    871         except IndexingError:
    872             pass

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _getitem_lowerdim(self,                                                                                                               tup)
    996         for i, key in enumerate(tup):
    997             if is_label_like(key) or isinstance(key, tuple):
--> 998                 section = self._getitem_axis(key, axis=i)
    999
   1000                 # we have yielded a scalar ?

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _getitem_axis(self, key,                                                                                                               axis)
   1909
   1910         # fall thru to straight lookup
-> 1911         self._validate_key(key, axis)
   1912         return self._get_label(key, axis=axis)
   1913

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _validate_key(self, key,                                                                                                               axis)
   1786
   1787             try:
-> 1788                 key = self._convert_scalar_indexer(key, axis)
   1789                 if not ax.contains(key):
   1790                     error()

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in _convert_scalar_indexer(                                                                                                              self, key, axis)
    259         ax = self.obj._get_axis(min(axis, self.ndim - 1))
    260         # a scalar
--> 261         return ax._convert_scalar_indexer(key, kind=self.name)
    262
    263     def _convert_slice_indexer(self, key, axis):

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in _convert_scalar_inde                                                                                                              xer(self, key, kind)
   1677             elif kind in ['loc'] and is_integer(key):
   1678                 if not self.holds_integer():
-> 1679                     return self._invalid_indexer('label', key)
   1680
   1681         return key

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexes/base.py in _invalid_indexer(sel                                                                                                              f, form, key)
   1861                         "indexers [{key}] of {kind}".format(
   1862                             form=form, klass=type(self), key=key,
-> 1863                             kind=type(key)))
   1864
   1865     def get_duplicates(self):

TypeError: cannot do label indexing on <class 'pandas.core.indexes.base.Index'> with these indexers [0                                                                                                              ] of <class 'int'>

In [101]: data.loc[data.three > 5,'two']
Out[101]:
Colorado     5
Utah         9
New York    13
Name: two, dtype: int64

In [102]: data.get_values
Out[102]:
<bound method NDFrame.get_values of           one  two  three  four
Ohio        0    0      0     0
Colorado    0    5      6     7
Utah        8    9     10    11
New York   12   13     14    15>

In [103]: data.get_values['one']
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-103-981a515d65a7> in <module>
----> 1 data.get_values['one']

TypeError: 'method' object is not subscriptable

In [104]: data.get_values()
Out[104]:
array([[ 0,  0,  0,  0],
       [ 0,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])

In [105]: data.get_values['Ohio']
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-105-f17bc948ee04> in <module>
----> 1 data.get_values['Ohio']

TypeError: 'method' object is not subscriptable

In [106]: data.get_values['Ohio','two']
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-106-66233ea3cf1a> in <module>
----> 1 data.get_values['Ohio','two']

TypeError: 'method' object is not subscriptable

In [107]: ?DataFrame.get-values
Object `DataFrame.get-values` not found.

In [108]: ?DataFrame.get_values

In [109]: ?DataFrame.get_value
Signature: DataFrame.get_value(self, index, col, takeable=False)
Docstring:
Quickly retrieve single value at passed column and index

.. deprecated:: 0.21.0
    Use .at[] or .iat[] accessors instead.

Parameters
----------
index : row label
col : column label
takeable : interpret the index/col as indexers, default False

Returns
-------
value : scalar value
File:      ~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py
Type:      function

In [110]: data.get_value['Ohio','two']
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-110-388bb3d74d00> in <module>
----> 1 data.get_value['Ohio','two']

TypeError: 'method' object is not subscriptable

In [111]: data.get_value['Ohio']
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-111-320e7bee640e> in <module>
----> 1 data.get_value['Ohio']

TypeError: 'method' object is not subscriptable

In [112]: data.at['two']
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-112-85b04c907e22> in <module>
----> 1 data.at['two']

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in __getitem__(self, key)
   2140
   2141         key = self._convert_key(key)
-> 2142         return self.obj._get_value(*key, takeable=self._takeable)
   2143
   2144     def __setitem__(self, key, value):

TypeError: _get_value() missing 1 required positional argument: 'col'

In [113]: data.at['ohio','two']
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
<ipython-input-113-797c7f6f9acd> in <module>
----> 1 data.at['ohio','two']

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/indexing.py in __getitem__(self, key)
   2140
   2141         key = self._convert_key(key)
-> 2142         return self.obj._get_value(*key, takeable=self._takeable)
   2143
   2144     def __setitem__(self, key, value):

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/frame.py in _get_value(self, index, col                                                                                                              , takeable)
   2537
   2538         try:
-> 2539             return engine.get_value(series._values, index)
   2540         except (TypeError, ValueError):
   2541

pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_value()

pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_value()

pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc()

pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item()

pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item()

KeyError: 'ohio'

In [114]: data.at['Ohio','two']
Out[114]: 0

In [115]: data.at['Ohio','three']
Out[115]: 0

In [116]: data.iat[0,0]
Out[116]: 0

In [117]: data.iat[0,2]
Out[117]: 0

In [118]: data.iat[0,3]
Out[118]: 0

In [119]: data.iat[3,3]
Out[119]: 15

In [120]: data.irow['Ohio']
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-120-e4af8d083c01> in <module>
----> 1 data.irow['Ohio']

~/.conda/envs/torch_04/lib/python3.5/site-packages/pandas/core/generic.py in __getattr__(self, name)
   4374             if self._info_axis._can_hold_identifiers_and_holds_name(name):
   4375                 return self[name]
-> 4376             return object.__getattribute__(self, name)
   4377
   4378     def __setattr__(self, name, value):

AttributeError: 'DataFrame' object has no attribute 'irow'

In [121]: ?DataFrame.irow
Object `DataFrame.irow` not found.

In [122]: ?DataFrame.icol
Object `DataFrame.icol` not found.

In [123]: ?Series.icol
Object `Series.icol` not found.


